---
layout:     post
title:      C++ Pointer (archieved)
subtitle:   
date:       2018-07-12
author:     Boyan
header-img: img/post-bg-math.jpg
catalog: true
tags:
    - C++
---
# Pointer
## 从计算机硬件的角度看变量的概念：
变量从底层硬件到程序软件，有三个不同的维度：
以二进制形式存在的值 -> 用以访问该值的起始地址 -> 表现在高级语言程序中的变量名 
       255                                 <0x1FA10AB3>                                      x
pointer 就是 用以访问变量的 地址值
 
地址值 提取符&： 通过在变量名称前加上 &，来访问该变量的地址值（指针）(*x 就是 变量x的指针)
变量值 访问符* ： 通过在地址名称前加上 *，来访问该地址指向的存储值
 
理解：
`（int a = 10）  ->    *(&a)  == a `
 
指针变量：专门用于存储 地址值（即，指针）的变量：
例如： a =10;  b = &a，

此时 变量b 为 变量a的 指针变量，有自己独立的一整套变量名，地址值，与存储值。
称"变量b 为指向 变量a 的指针变量"
  初始化一个指针变量：
```
int a = 5 ;
int *b  =  NULL; 
b = &a 
```
（解读：初始化指针变量时，须声明 指针类型（即base variable 的变量类型）！
     指针类型，用于提示计算机应分配给变量的内存空间
     指针变量名前所加的 *，用以区分  指针变量  和  普通变量  并不是 存储值提取符）
（base variable type 是针对arry这样的compound type的定义）
 
注：以 组合型数据类型 为基变量：
```
int (*p)[4]
int a = [3][4]
int (*p)[4] = a   //  解读：“二维数组” 的变量名，是指向二维数组第一个元素的指针。
二维数组的第一个元素，是“4个int组成的数组”，其数据类型，为“4个int组合成的数组 int [4]"
这里，因为变量名要加上*，故写作“int (*p)[4]”
``` 
## 利用指针变量访问 (变量的）存储值
对指针变量做 ++ 运算：

概念上：会把内存中距离 该指针变量指向的储存值 最近的下一块内存的起始地址分配给
该指针变量

数值上:：我们知道地址值为十六进制的数字串，ptr++ 在数值上等于 原地址加上 计算机分配给（该指针所指向的内存值） 的字节数

## 优先级：
后置++ 优先于 *运算： *p++ 与 (*p)++ 的含义截然不同
 
推广：“pointer + 整数” 运算：
应用在访问数组元素时！
 
## 指针比较大小：
pointer1  <  pointer2， 当且仅当用以 pointer1指向的值的存储  先于 pointer2 指向的值的存储
 
 
 
## 数组的指针：
若a为"数组的指针"，那么(*a)访问到的内存是“数组”。
而a为"数组第一个元素的指针"，（*a）访问到的是数组的第一个元素的值。
因此“数组实体”的储存形式，是“数组的第一个元素”。
a 与 &(a[0]) 等价
（数组实体 的储存形式，是数组的 第一位元素 + 元素个数？）

 对pointer使用下标运算符，将访问结果位置的 实体值
对于 
```
int a[5] = {0,1,2,3,4}               
a[i]  =  *(a+i)
```
 
 
## 对数组名进行 & 运算：
根据C语言规范，数组名出现在 & 运算符之后时，就不再代表数组第一个元素的地址了
array    是指向数组第一个元素的指针，其 基类型 为“数组第一个元素的类型”（如 int *p）
&array 将返回指向整个数组的一个指针，其 基类型 为“长度为n的xx型数组”（如 int (*p)[4] ）
 
（注：*(&array) = array，即“数组名”，执行数组第一个元素的指针 ）
 
array 与 &array  在地址值上相同，但管辖范围不同。在参与地址运算时，由于指针的基类型不同，
出现 p+1 运算时，跳过的内存数不同。

## 二维数组的指针：

（以上方所表示的二维数组为例）
 
- 二维数组是以一维数组的指针的形式，储存一维数组的。
所以a[1][2] 两次使用下标运算符，才会有意义。
 
- 二维数组名：a。是指向二维数组第一个元素a[0]的指针。是指向“包含四个int元素的一维数组”的指针。
二维数组的第一个元素：a[0]。是指向“包含四个int元素的一维数组” 的 “第一个元素” 的 指针。
 
- a[0], &(a[0][0]) 三指针的地址值相同，但三者的基类型不同。
或者这么讲：指针也有“维度”。
 
注：一种简单的理解指针级别的方式是，令数组名b = a[0]。 
 
 ## 指向字符串的指针：

```
cout << 字符串的指针 // 会打印出整个字符串
```
若想打印出字符串的地址，需要对指针p进行静态类型强转 static_cast<void*>(pointer)

 
示例程序：

 
## 指针做函数参数：
 
- 指针做函数实参：函数有权修改主函数的数据
 
- 限制指针做函数实参的权限：利用 “指向符号常量的指针” const int *p 。
指向符号常量的指针，无权修改该指针指向的数值
 
- 数组名做形参，可直接定义数组 int array[ ][n]，C++编译器会将 数组名 当做指针变量处理

 
## 指针做函数返回值：
 
- 定义函数名时，需要申明 返回值的基类型,将*加至函数名前。如 int *getMax(a,b){……}
 
- 返回函数内的局部变量的指针：危险！函数内的局部变量在函数调用完毕后，其内存会被释放掉。
      解决方案：使用静态局部变量。(如 static int a = 10)
 
- 静态局部变量：static int  a  存储其值的内存，当所在函数调用完毕后，将保留原值，不会被释放掉。
- 动态局部变量：          int a
 
 
## 函数指针：函数也有入口地址，可用一个指针指向
 
- 定义形式： int (*PointerName) (int x, float y, char z)
 
- 赋值：用原型匹配函数名字赋值
 
- 利用函数指针向函数传递函数: 

（注：对于空指针 void *elem1，如果写 (*elem1) 将出现编译错误，因为编译器不知道空指针所指向的内存空间有多大。
故，调用elem1的值时，需进行类型强转 (unsigned int *) elem1 ）


