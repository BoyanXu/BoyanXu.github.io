---
layout:     post
title:      Seek Equilibrium between Commerciality & Functionality
subtitle:   What sort of elegance should programmer worship
date:       2019-06-29
author:     Boyan
header-img: img/post-bg-math.jpg
catalog: true
tags:
    - meditation
---

## Seek Equilibrium between **Commerciality & Functionality**

When I just got start with programming, I frequently felt frustrated with softwares specially designed for programmers, like git, ssh, or in a more general sense, python, Flask, and pristine Linux. At that time, because I hadn't distinguish the programmer-oriented software with the customer-oriented software, my methodology approaching those softwares is both dumb and awkward - simply by searching the corresponding commands and code snippets summarized by some random websites or blogs, then copying and tuning those uninterpretable codes constantly until they seem to function as my expectation. However, even though I could produce functional software eventually after going through an recursive and inefficient trial-and-error procedure, I always found that I could barely remember anything several weeks later after accomplishment.

Now I know what mistake I've made: I tried to master programmer-oriented software with a customer's approach.

The customer software, by which I mean the commercial and usually user-friendly softwares that are designed to hide most of its complexity from their users, has misled the public and even some programmers about the way to master softwares since their were first on sale. In general, a successful customer-oriented software should be an easy, approachable tool with elaborate design of interaction with users. To achieve such business success, programmers are required to design natural, but redundant interaction layer in their software, designers to simplify the simplified interaction logic with obvious favicons, and animations, product managers to design impressive, tempting product demo videos... All of the efforts are made to hide the inner complexity of their software from their users. As recipients of such flattering software design, users have gradually entertained an erroneous intuition about software's real face in the past decades. The dominant business world of software industry have conveyed a dangerous stereotype to all the human beings, that "good software should be easy to use." With such stereotype, the majority of people tend to criticize any sophisticated software, damn their deviation from the aesthetic of simplicity, while feeling themselves are tasteful, just like myopic monkeys and arrogant giant babies. "The software should behave like this!", "Why they just don't implement this feature!?", "I have fucking no idea with the design of this bullshit."

When giant babies tried to suck pacifier with the meticulous help from their moms, everything seems to be fine, but if you let them learn how to use chopsticks by themselves, they will never truly master it, because in giant babies' perceptive, the chopsticks should be designed as easy to use as a pacifier, without ever trying to think about the what problem chopsticks is designed to solve, what makes it an efficient and workable solution, and what makes it an splendid and immortal/ design. They never feel curious about the peculiar structure of chopsticks, neither ever query themselves how to use it eloquently. They are limited by their poor imagination, constrained by their stereotype, and therefore lose the chance of extending their capacity for hard work.

I was exactly a giant baby when I tried to master programmer-oriented software with a customer's approach. I comprehended the functionality of software with my naive intuition. Whenever the software's behavior deviate my assumption, I have to search the cause of that tiny behavior and do another round of copy-and-paste to make make it runs, instead of extending my comprehension of the software itself. Consequentially, I never actively think about why the commands and code snippets have that strange appearance and organization, and never try to understand the problem it was trying to solve nor the solution iteself in the form of software.

As I observed, programmer-oriented software is an interactive interface for one's comprehension of the technology behind. Your mastery level of a programmer-oriented software is principally determinate by your understanding of the technology beneath the software, not by how long you suffer from it, not by how many trivial tasks you accomplished with it. As programmers, we have to understand, the programmer-oriented software is not a exterior tool resides in our screen, but an interior interface of our mental intelligence. Your comprehension of the technology beneath the software forms the abstract architecture of this interior interface, then the command and the code snippets are only the carrier of instructions from our mind crossing through that interface, are only the language we proficiently express our idea on how to solve a complicated task based on pre-defined concise syntax.
